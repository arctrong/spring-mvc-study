<!--VARIABLES {"title": "Sessions and cookies", "SORT_ORDER": "080", "code": "sessions_and_cookies"}-->

[TOC]

[2.13]: <!--page refs-->#ref_2_13
[2.14]: <!--page refs-->#ref_2_14
[16]: <!--page refs-->#ref_16

----------------------------------------------------------------------------------------------------
Mar 30, 2023

<!--index ["cookies, HTTP"]-->
# What is session and cookies

[[2.13][]]

HTTP is a stateless protocol so it doesn't save information between the requests. **Cookies**
were invented in maybe 1995 to fill this gap.

Also see [[16][]].

----------------------------------------------------------------------------------------------------
# Implement cookies transfer

[[2.13][], [12:23](https://youtu.be/cpFfzE9eGT0?t=743)]

This is the first simple implementation that is probably not to be used in production.

> Git commit: [`84ef7a5077be8aebf246e238b4f66d4efc2f220a`](
> <!--path patches-->84ef7a5077be8aebf246e238b4f66d4efc2f220a.html)
> first simple cookie usage demonstrated

In the `/validate-submit` endpoint we create a `Cookie` and add it to the `HttpServletResponse`
object that is provided by Spring MVC via the corresponding controller method parameter 
`response`. After the response is received the added cookie may be viewed in the debugger (F12):

![](<!--path pict-->debug_cookies.png)

The added cookie is sent by the browser with every subsequent request so it can be used on every
page like the one that is returned by the `/validate` endpoint.

----------------------------------------------------------------------------------------------------
<!--index ["@CookieValue"]-->
# Managing cookies using Spring

[[2.13][], [37:28](https://youtu.be/cpFfzE9eGT0?t=2248)]

The above method is much inconvenient especially when used in a lot of controllers. The Spring 
`@CookieValue` annotation may help simplify this task (see the [`EmailController`](
<!--path code-->web-app-spring-adv3/src/main/java/springmvcstudy2/controllers/EmailController.java)
class):

````code
    @RequestMapping("/sendEmail")
    public String sendEmail(@CookieValue("myApp.userName") String userName, Model model) {
        model.addAttribute("sendEmailDto", new SendEmailDto());
        model.addAttribute("userName", userName);
        return "send-email-page";
    }
````

> Git commit: [`fe7f898864fc585ea03e2e6e195c46e9700cf9ac`](
> <!--path patches-->fe7f898864fc585ea03e2e6e195c46e9700cf9ac.html)
> using @CookieValue annotation

----------------------------------------------------------------------------------------------------
Apr 1, 2023

<!--index ["sessions, HTTP"]-->
# Using sessions

[[2.13][], [43:25](https://youtu.be/cpFfzE9eGT0?t=2605)]

Cookies are stored inside the client's computer and the client may not allow to drop such kind
of litter inside their system.

Cooking processing may be costly as they are just text files. Complex structures may be have
very large size. Also cookies may have size limitation.

<p><img src="<!--path pict-->session_cookie_sequence.png" class="floatRight" /></p>

To address these problems there is an alternative called **sessions**.

A client sends a request. The application doesn't send the whole set of data to the client
but instead saves the session state in the database and returns to the client a response with above
single session ID.

On a next request the session ID cookie is sent back to the application that retrieves the session
state by this session ID and returns to the client the customized response.

<p style="clear: both;"></p>

In the [`ValidatedController`](
<!--path code-->web-app-spring-adv3/src/main/java/springmvcstudy2/controllers/ValidatedController.java)
class using setting a session attribute:

````code
    @RequestMapping("/validate-submit")
    public String showCalculatePageSpring(<...>,
                                          HttpSession session) {
        .  .  .
        session.setAttribute("userName", dto.getName1());
        return "result-page-spring";
    }
````

Then this attribute may be used on the JSP page like [`process-email-page.jsp`](
<!--path code-->web-app-spring-adv3/src/main/webapp/WEB-INF/view/process-email-page.jsp):

````xml
.  .  .
<h1>Hi ${userName}!</h1>
.  .  .
````

Or the session attributes may be transformed and set into the model likes it's don in the
[`EmailController`](
<!--path code-->web-app-spring-adv3/src/main/java/springmvcstudy2/controllers/EmailController.java)
class:

````code
    @RequestMapping("/process-email")
    public String processEmail(@ModelAttribute SendEmailDto sendEmailDto,
                               HttpSession session, Model model) {
        model.addAttribute("userName", "dear " + session.getAttribute("userName"));
        return "process-email-page";
    }
````

!!! important
    On a JSP page, when resolving a placeholder variable, first an attempt is done to find this
    variable in the model and if not found then it's searched in the session.

As servers have still limited storage capacity and the number of requests and different sessions 
may be huge, it's not recommended to store unnecessary data in sessions.

> Git commit: [`41ac2ee44af044b776a036a7bd891d9cf4347cf5`](
> <!--path patches-->41ac2ee44af044b776a036a7bd891d9cf4347cf5.html)
> session usage demonstrated

----------------------------------------------------------------------------------------------------
# Session timeout

[[2.13][], [1:21:08](https://youtu.be/cpFfzE9eGT0?t=4868)]

!!! note
    The `javax.servlet.http.HttpSession` is not a part of Spring.

<!--index ["timeout, session", "session timeout"]-->
It may be unreasonable or even impossible to hold used session data forever. To limit the storage
period of time (in minutes) the following parameter may be used in the `web.xml` file:

````xml
<session-config> 
    <session-timeout>20</session-timeout>
</session-config>
````

In the code-based configuration (e.g. in the [`ValidatedController`](
<!--path code-->web-app-spring-adv3/src/main/java/springmvcstudy2/controllers/ValidatedController.java)
class) the `javax.servlet.http.HttpSession` object may be used for that
(in seconds):

````code
    @RequestMapping("/validate-submit")
    public String showCalculatePageSpring(@Valid @ModelAttribute("dto") UserInfoValidatedDto dto, 
                                          HttpSession session) {
    
        session.setAttribute("userName", dto.getName1());
        session.setMaxInactiveInterval(20);
        
        return "result-page-spring";
    }
````

It's proved that after 20 seconds of inactivity the session attribute `userName` is no longer
available. We are now not going to preserve this code in the project.

----------------------------------------------------------------------------------------------------
<!--index ["@SessionAttributes"]-->
# Using `@SessionAttributes` annotation

[[2.13][], [1:26:59](https://youtu.be/cpFfzE9eGT0?t=5219)]

!!! note
    Using the following approach may be pretty tricky and may take much time for investigation of
    possible errors. See [here](<!--page sessions_and_cookies-->#conversational_scope) for more
    extensive explanation.

The `@org.springframework.web.bind.annotation.SessionAttributes` annotation is added to the 
[`ValidatedController`](
<!--path code-->web-app-spring-adv3/src/main/java/springmvcstudy2/controllers/ValidatedController.java)
class:

````code
@Controller
@SessionAttributes("userInfoDto")
public class ValidatedController {

    @RequestMapping("/validate")
    public String showHomePageSpring(Model model) {
        model.addAttribute("userInfoDto", new UserInfoValidatedDto());
        return "home-page-validated";
    }
    .  .  .
````

!!! note
    Multiple model attributes may be specified in the `@SessionAttributes` annotation. 
    Also see [[2.13][], [1:39:39](https://youtu.be/cpFfzE9eGT0?t=5979)].

In the [`EmailController`](
<!--path code-->web-app-spring-adv3/src/main/java/springmvcstudy2/controllers/EmailController.java)
we just remove the explicit session handling code.

In the views:

- [`send-email-page.jsp`](
    <!--path code-->web-app-spring-adv3/src/main/webapp/WEB-INF/view/send-email-page.jsp) and
- [`process-email-page.jsp`](
    <!--path code-->web-app-spring-adv3/src/main/webapp/WEB-INF/view/process-email-page.jsp)
   
We just use the specified session attribute like this:

````xml
.  .  .
<h1>Hi ${userInfoDto.name1}!</h1>
.  .  .
````
    
> Git commit: [`82d604c452010585bc401a28bb02907f8c378314`](
> <!--path patches-->82d604c452010585bc401a28bb02907f8c378314.html)
> @SessionAttributes annotation used

----------------------------------------------------------------------------------------------------
Apr 3, 2023

<!--index ["conversational scope"]--><a name="conversational_scope"></a>
# Conversational scope

new simple project created to make the description more clear. The URL is 
<http://localhost:8080/web-app-spring-sessions/ui/first>.

[[2.14][], [0:40](https://youtu.be/ezty6XhOpF8?t=40)]

> Git commit: [`92ef2e0ce13ce794115d2d47695b80ec1b2d8ea4`](
> <!--path patches-->92ef2e0ce13ce794115d2d47695b80ec1b2d8ea4.html)
> new project created for sessions investigation


<!--index ["request scope"]-->
## Request scope

[[2.14][], [4:07](https://youtu.be/ezty6XhOpF8?t=247)]

This narration is going to be done for further comparison with the upper level scope.

Request scope defines data that is valid during a single request handling process, e.g. from the
request receipt to the response result sending. As the request is processed (like the rendered view
is sent to the client) the request scope is destroyed.

Two controller methods are defined:

````code
    @RequestMapping("/first")
    public String firstHandler(Model model) {
        model.addAttribute("firstName", "Jan");
        model.addAttribute("lastName", "Hus");
        return "index";
    }

    @RequestMapping("/second")
    public String secondHandler(Model model) {
        String firstName = (String) model.getAttribute("firstName");
        System.out.println("firstName=" + firstName);
        return "index";
    }
````

The first one sets two model attributes and the second one tries to asses it. The `Model` object
here has the request scope so the instances are different for the two requests and so in the
second method the requested attribute is absent:

````shell
firstName=null
````

The page is going to look like this:

![](<!--path pict-->request_scope.png)

The first URL is <http://localhost:8080/web-app-spring-sessions/ui/first>.

> Git commit: [`705e5a346357e303c5b7dec577c7e82bcf1592a5`](
> <!--path patches-->705e5a346357e303c5b7dec577c7e82bcf1592a5.html)
> request scope demonstrated

[[2.14][], [16:17](https://youtu.be/ezty6XhOpF8?t=977)]


