<!--VARIABLES {"title": "Sessions and cookies", "SORT_ORDER": "080", "code": "sessions_and_cookies"}-->

[TOC]

[2.13]: <!--page refs-->#ref_2_13
[2.14]: <!--page refs-->#ref_2_14
[16]: <!--page refs-->#ref_16

----------------------------------------------------------------------------------------------------
Mar 30, 2023

<!--index ["cookies, HTTP"]-->
# What is session and cookies

[[2.13][]]

HTTP is a stateless protocol so it doesn't save information between the requests. **Cookies**
were invented in maybe 1995 to fill this gap.

Also see [[16][]].

----------------------------------------------------------------------------------------------------
# Implement cookies transfer

[[2.13][], [12:23](https://youtu.be/cpFfzE9eGT0?t=743)]

This is the first simple implementation that is probably not to be used in production.

> Git commit: [`84ef7a5077be8aebf246e238b4f66d4efc2f220a`](
> <!--path patches-->84ef7a5077be8aebf246e238b4f66d4efc2f220a.html)
> first simple cookie usage demonstrated

In the `/validate-submit` endpoint we create a `Cookie` and add it to the `HttpServletResponse`
object that is provided by Spring MVC via the corresponding controller method parameter 
`response`. After the response is received the added cookie may be viewed in the debugger (F12):

![](<!--path pict-->debug_cookies.png)

The added cookie is sent by the browser with every subsequent request so it can be used on every
page like the one that is returned by the `/validate` endpoint.

----------------------------------------------------------------------------------------------------
<!--index ["@CookieValue"]-->
# Managing cookies using Spring

[[2.13][], [37:28](https://youtu.be/cpFfzE9eGT0?t=2248)]

The above method is much inconvenient especially when used in a lot of controllers. The Spring 
`@CookieValue` annotation may help simplify this task (see the [`EmailController`](
<!--path code-->web-app-spring-adv3/src/main/java/springmvcstudy2/controllers/EmailController.java)
class):

````code
    @RequestMapping("/sendEmail")
    public String sendEmail(@CookieValue("myApp.userName") String userName, Model model) {
        model.addAttribute("sendEmailDto", new SendEmailDto());
        model.addAttribute("userName", userName);
        return "send-email-page";
    }
````

> Git commit: [`fe7f898864fc585ea03e2e6e195c46e9700cf9ac`](
> <!--path patches-->fe7f898864fc585ea03e2e6e195c46e9700cf9ac.html)
> using @CookieValue annotation

----------------------------------------------------------------------------------------------------
Apr 1, 2023

<!--index ["sessions, HTTP"]-->
# Using sessions

[[2.13][], [43:25](https://youtu.be/cpFfzE9eGT0?t=2605)]

Cookies are stored inside the client's computer and the client may not allow to drop such kind
of litter inside their system.

Cooking processing may be costly as they are just text files. Complex structures may be have
very large size. Also cookies may have size limitation.

<p><img src="<!--path pict-->session_cookie_sequence.png" class="floatRight" /></p>

To address these problems there is an alternative called **sessions**.

A client sends a request. The application doesn't send the whole set of data to the client
but instead saves the session state in the database and returns to the client a response with above
single session ID.

On a next request the session ID cookie is sent back to the application that retrieves the session
state by this session ID and returns to the client the customized response.

<p style="clear: both;"></p>

In the [`ValidatedController`](
<!--path code-->web-app-spring-adv3/src/main/java/springmvcstudy2/controllers/ValidatedController.java)
class using setting a session attribute:

````code
    @RequestMapping("/validate-submit")
    public String showCalculatePageSpring(<...>,
                                          HttpSession session) {
        .  .  .
        session.setAttribute("userName", dto.getName1());
        return "result-page-spring";
    }
````

Then this attribute may be used on the JSP page like [`process-email-page.jsp`](
<!--path code-->web-app-spring-adv3/src/main/webapp/WEB-INF/view/process-email-page.jsp):

````xml
.  .  .
<h1>Hi ${userName}!</h1>
.  .  .
````

Or the session attributes may be transformed and set into the model likes it's don in the
[`EmailController`](
<!--path code-->web-app-spring-adv3/src/main/java/springmvcstudy2/controllers/EmailController.java)
class:

````code
    @RequestMapping("/process-email")
    public String processEmail(@ModelAttribute SendEmailDto sendEmailDto,
                               HttpSession session, Model model) {
        model.addAttribute("userName", "dear " + session.getAttribute("userName"));
        return "process-email-page";
    }
````

!!! important
    On a JSP page, when resolving a placeholder variable, first an attempt is done to find this
    variable in the model and if not found then it's searched in the session.

As servers have still limited storage capacity and the number of requests and different sessions 
may be huge, it's not recommended to store unnecessary data in sessions.

> Git commit: [`41ac2ee44af044b776a036a7bd891d9cf4347cf5`](
> <!--path patches-->41ac2ee44af044b776a036a7bd891d9cf4347cf5.html)
> session usage demonstrated

----------------------------------------------------------------------------------------------------
# Session timeout

[[2.13][], [1:21:08](https://youtu.be/cpFfzE9eGT0?t=4868)]

!!! note
    The `javax.servlet.http.HttpSession` is not a part of Spring.

<!--index ["timeout, session", "session timeout"]-->
It may be unreasonable or even impossible to hold used session data forever. To limit the storage
period of time (in minutes) the following parameter may be used in the `web.xml` file:

````xml
<session-config> 
    <session-timeout>20</session-timeout>
</session-config>
````

In the code-based configuration (e.g. in the [`ValidatedController`](
<!--path code-->web-app-spring-adv3/src/main/java/springmvcstudy2/controllers/ValidatedController.java)
class) the `javax.servlet.http.HttpSession` object may be used for that
(in seconds):

````code
    @RequestMapping("/validate-submit")
    public String showCalculatePageSpring(@Valid @ModelAttribute("dto") UserInfoValidatedDto dto, 
                                          HttpSession session) {
    
        session.setAttribute("userName", dto.getName1());
        session.setMaxInactiveInterval(20);
        
        return "result-page-spring";
    }
````

It's proved that after 20 seconds of inactivity the session attribute `userName` is no longer
available. We are now not going to preserve this code in the project.

----------------------------------------------------------------------------------------------------
<!--index ["@SessionAttributes"]-->
# Using `@SessionAttributes` annotation

[[2.13][], [1:26:59](https://youtu.be/cpFfzE9eGT0?t=5219)]

!!! note
    Using the following approach may be pretty tricky and may take much time for investigation of
    possible errors. See [here](<!--page sessions_and_cookies-->#conversational_scope) for more
    extensive explanation.

The `@org.springframework.web.bind.annotation.SessionAttributes` annotation is added to the 
[`ValidatedController`](
<!--path code-->web-app-spring-adv3/src/main/java/springmvcstudy2/controllers/ValidatedController.java)
class:

````code
@Controller
@SessionAttributes("userInfoDto")
public class ValidatedController {

    @RequestMapping("/validate")
    public String showHomePageSpring(Model model) {
        model.addAttribute("userInfoDto", new UserInfoValidatedDto());
        return "home-page-validated";
    }
    .  .  .
````

!!! note
    Multiple model attributes may be specified in the `@SessionAttributes` annotation. 
    Also see [[2.13][], [1:39:39](https://youtu.be/cpFfzE9eGT0?t=5979)].

In the [`EmailController`](
<!--path code-->web-app-spring-adv3/src/main/java/springmvcstudy2/controllers/EmailController.java)
we just remove the explicit session handling code.

In the views:

- [`send-email-page.jsp`](
    <!--path code-->web-app-spring-adv3/src/main/webapp/WEB-INF/view/send-email-page.jsp) and
- [`process-email-page.jsp`](
    <!--path code-->web-app-spring-adv3/src/main/webapp/WEB-INF/view/process-email-page.jsp)
   
We just use the specified session attribute like this:

````xml
.  .  .
<h1>Hi ${userInfoDto.name1}!</h1>
.  .  .
````
    
> Git commit: [`82d604c452010585bc401a28bb02907f8c378314`](
> <!--path patches-->82d604c452010585bc401a28bb02907f8c378314.html)
> @SessionAttributes annotation used

----------------------------------------------------------------------------------------------------
Apr 3, 2023

<!--index ["conversational scope"]--><a name="conversational_scope"></a>
# Conversational scope

New simple project created to make the description more clear. The URL is 
<http://localhost:8080/web-app-spring-sessions/ui/first>.

[[2.14][], [0:40](https://youtu.be/ezty6XhOpF8?t=40)]

> Git commit: [`92ef2e0ce13ce794115d2d47695b80ec1b2d8ea4`](
> <!--path patches-->92ef2e0ce13ce794115d2d47695b80ec1b2d8ea4.html)
> new project created for sessions investigation


<!--index ["request scope"]-->
## Request scope

[[2.14][], [4:07](https://youtu.be/ezty6XhOpF8?t=247)]

This narration is going to be done for further comparison with the upper level scope.

Request scope defines data that is valid during a single request handling process, e.g. from the
request receipt to the response result sending. As the request is processed (like the rendered view
is sent to the client) the request scope is destroyed.

Two controller methods are defined:

````code
@Controller
public class FirstController {

    @RequestMapping("/first")
    public String firstHandler(Model model) {
        model.addAttribute("firstName", "Jan");
        model.addAttribute("lastName", "Hus");
        return "index";
    }

    @RequestMapping("/second")
    public String secondHandler(Model model) {
        String firstName = (String) model.getAttribute("firstName");
        System.out.println("firstName=" + firstName);
        return "index";
    }
}
````

The first one sets two model attributes and the second one tries to access it. The `Model` object
here has the request scope so the instances are different for the two requests and so in the
second method the requested attribute is absent:

````shell
firstName=null
````

The page is going to look like this:

![](<!--path pict-->request_scope.png)

The first URL is <http://localhost:8080/web-app-spring-sessions/ui/first>. As for now the second 
link opens the page where all fields are empty.

> Git commit: [`705e5a346357e303c5b7dec577c7e82bcf1592a5`](
> <!--path patches-->705e5a346357e303c5b7dec577c7e82bcf1592a5.html)
> request scope demonstrated


## Adding conversational scope

[[2.14][], [16:17](https://youtu.be/ezty6XhOpF8?t=977)]

Just add the `@SessionAttributes("firstName")` annotation to the `FirstController` controller
()see above) and see what happens:

````code
@Controller
@SessionAttributes("firstName")
public class FirstController {
.  .  .
````

<p><img src="<!--path pict-->session_scope_01.png" class="floatRight" /></p>

When the first handler method is being called the two model attributes still exist in the *request 
scope* but the attribute `firstName` also gets copied to the *session scope* (fig. 1).

When the first method is finished the two model attributes are removed from the *request scope*
but the attribute `firstName` remains in the *session scope* (fig. 2).

When the second handler method is called the session scope attributes get copied to the 
request scope (fig. 3).

<p style="clear: both;"></p>

So unlike the previous case we see:

````shell
firstName=Jan
````

And the second link shown above opens the page where the first field "First name" is filled.

> Git commit: [`c858def2e0084a4d7b40a7e045101bcb7f2017dc`](
> <!--path patches-->c858def2e0084a4d7b40a7e045101bcb7f2017dc.html)
> @SessionAttributes annotation added


<!--index ["requestScope, JSP attribute", "sessionScope, JSP attribute"]-->
## Specify scope explicitly in JSP page

[[2.14][], [32:50](https://youtu.be/ezty6XhOpF8?t=1970)]

In the JSP page add:

````xml
.  .  .
<strong>First name from the request: </strong>${requestScope.firstName}<br />
<strong>First name from the session: </strong>${sessionScope.firstName}<br />
.  .  .
````

that'll show that the attribute values are the same.

> Git commit: [`8787b67b11429a6f0369395418dfca87a74a1ab6`](
> <!--path patches-->8787b67b11429a6f0369395418dfca87a74a1ab6.html)
> scopes explicitly specified


## Get things simpler

Specify the other field as session scoped:

````code
@Controller
@SessionAttributes({"firstName", "lastName"})
public class FirstController {
.  .  .
````
[[2.14][], [32:50](https://youtu.be/ezty6XhOpF8?t=1970)]
Now we don't need to even mention the model attributes in the second handler:

````code
    @RequestMapping("/second")
    public String secondHandler() {
        return "index";
    }
````

This will work as in the JSP page the attributes `${firstName}` and `${lastName}` will be first
looked up in the request scope and then, if not found, in the session scope.

> Git commit: [`e51ab82cd5dbff738d0564796176a933e39987be`](
> <!--path patches-->e51ab82cd5dbff738d0564796176a933e39987be.html)
> all attributes added to the session scope


<!--index ["SessionStatus object", "session completion"]-->
## Completing the conversation

[[2.14][], [45:04](https://youtu.be/ezty6XhOpF8?t=2704)]

In the second handler method adding a `org.springframework.web.bind.support.SessionStatus` 
parameter and using it for the session completion:

````code
    @RequestMapping("/second")
    public String secondHandler(SessionStatus status) {
        status.setComplete();
        return "index";
    }

    @RequestMapping("/third")
    public String thirdHandler() {
        return "index";
    }
````

After that, in the third handler method the session attributes will be absent.

> Git commit: [`2977906fc61c5574f67e1db43f7ed544a2fbae5d`](
> <!--path patches-->2977906fc61c5574f67e1db43f7ed544a2fbae5d.html)
> conversation completing demonstrated


## Restrictions on `@SessionAttributes` annotation

[[2.14][], [1:03:41](https://youtu.be/ezty6XhOpF8?t=3821)]

Javadoc of `org.springframework.web.bind.annotation.SessionAttributes` states that usage of
conversation scope with `@SessionAttributes` annotation among different controllers may be buggy.
For exchanging data between different controllers it's better to use 
`javax.servlet.http.HttpSession` object or solutions like Spring authentication that is going
to be discussed later.

Addin a new controller:

````code
@Controller
public class SecondController {

    @RequestMapping("/normalMethod")
    public String normalHandler(Model model) {
        String firstName = (String) model.getAttribute("firstName");
        System.out.println("Inside normal handler firstName=" + firstName);
        return "index";
    }
}
````

In the handler method `normalHandler` the `firstName` attribute will be absent:

````shell
Inside normal handler firstName=null
````

But in the JSP view the corresponding attributes will be taken from the session.



Let's try to fix it:

````code
@Controller
public class SecondController {

    @RequestMapping("/normalMethod")
    public String normalHandler(@SessionAttribute("firstName") String firstName, Model model) {
        System.out.println("Inside normal handler firstName=" + firstName);
        model.addAttribute("firstName", "Dear " + firstName);
        return "index";
    }
}
````

This will work:

````shell
Inside normal handler firstName=Jan
````

!!! note
    <!--index ["@SessionAttribute"]-->
    Mind the fact that `@org.springframework.web.bind.annotation.SessionAttribute` is a different 
    annotation.

But there may be problems like the following. The solution works if we navigate from the first
handler method to the normal method of the second controller (see the picture below). 

![](<!--path pict-->conversational_scope.png)

But if we navigate to the normal method from the second handler method (where the session is
completed) the following error will be returned:

````
HTTP ERROR 400 Missing session attribute 'firstName' of type String
````

> Git commit: [`f5377bfa2557f2f886c9163fa47dc86190fb92f3`](
> <!--path patches-->f5377bfa2557f2f886c9163fa47dc86190fb92f3.html)
> problem with @SessionAttribute annotation


## `HttpSession` vs `@SessionAttribute`

[[2.14][], [1:33:41](https://youtu.be/ezty6XhOpF8?t=5621)]




